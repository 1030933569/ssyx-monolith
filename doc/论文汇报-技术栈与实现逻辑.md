# 论文汇报：技术栈与实现逻辑（小白版）

> 项目：优选社区购（`ssyx-monolith`）  
> 你可以理解成：**社区团购微信小程序** + **后端服务**（下单/库存/支付/搜索）  
> 适用：毕设/论文答辩汇报（按“是什么 → 怎么做 → 为什么这么做”）

---

## 0. 一句话介绍（开场 15 秒）

这是一个社区团购系统：用户在微信小程序里浏览商品 → 加入购物车 → 选择提货点（团长）→ 下单并微信支付 → 后端扣库存、更新订单状态，用户到提货点自提。

---

## 1. 系统整体长什么样（结构图）

仓库里有一张架构图（做 PPT 直接用）：

![](image/项目架构.png)

你讲的时候可以用这一句概括：

**小程序通过 HTTP 调后端 API，后端用 MySQL 存业务数据，用 Redis 做缓存/购物车/登录态，并对接微信登录与微信支付。**

---

## 2. 后端技术栈（用了什么、负责什么）

> 这里按“代码里真实落地”整理（不是只看 README 的“计划选型”）。

### 2.1 基础与框架

- 语言：Java 8（基于 Spring Boot 环境运行，技术成熟度高且社区生态完善）
- 核心框架：Spring Boot `2.3.6.RELEASE`（提供自动装配、快速启动并简化依赖版本管理能力）
- 构建：Maven 多模块聚合工程
- 统一返回/响应：`Result<T>`
- 接口规范与联调文档：Swagger2 + Knife4j `2.0.8`（提供美观强大的聚合 API 在线体验）

### 2.2 数据持久化与缓存计算

- 关系型数据库：MySQL 的 `5.7` 版本（业务系统核心底层数据存储介质） + 驱动 `MySQL Connector/J 8.0.33`
- 数据持久层框架：MyBatis-Plus `3.4.1`（简化单表基本增删改查操作，内置高效的分页拦截器）
- 连接池：HikariCP
- 非关系型数据库/内存计算：Redis `v6.0`（构建高性能 Key-Value 缓存层，用于存放热点数据、实现分布式锁与队列消峰）
- 分布式锁与高并发防控：Redisson（例如处理库存锁定逻辑防超卖）

### 2.3 登录与鉴权（小程序怎么“证明自己是谁”）

- Token：JWT（`common/common-util/src/main/java/cn/itedus/ssyx/common/utils/JwtHelper.java`）
- token 传递方式：请求头 `token`（`UserLoginInterceptor` 从 header 读取）
- 登录态缓存：Redis 保存 `UserLoginVo`
  - key：`user:login:{userId}`（`RedisConst.USER_LOGIN_KEY_PREFIX`）

关键代码：

- 拦截规则：`common/service-util/src/main/java/cn/itedus/ssyx/common/auth/LoginMvcConfigurerAdapter.java`
  - 拦截 `/api/**`
  - 放行 `/api/user/weixin/wxLogin/*`
- token 解析：`common/service-util/src/main/java/cn/itedus/ssyx/common/auth/UserLoginInterceptor.java`
- 用户上下文：`common/service-util/src/main/java/cn/itedus/ssyx/common/auth/AuthContextHolder.java`（ThreadLocal 存 userId/wareId）

### 2.4 微信能力

- 小程序登录：`jscode2session` 换 `openid`（`service/service-user/.../WeixinApiController.java`）
- 微信支付：统一下单/查单（`service/service-payment/.../WeixinServiceImpl.java`）

### 2.5 并发与稳定性（为什么不会重复下单/不会超卖）

- 下单防重：Redis + Lua（`service/service-order/.../OrderInfoServiceImpl.java` 的 `submitOrder`）
- 锁库存：Redisson 公平锁 + MySQL 更新（`service/service-product/.../SkuInfoServiceImpl.java` 的 `checkAndLock`）

### 2.6 “消息队列”（这版是简化实现）

本项目里虽然命名为 `RabbitService`，但在 `ssyx-monolith` 的落地实现中，**实际用 Redis 模拟 MQ**：

- 立即消息：Redis List（key：`ssyx.mq:queue`）
- 延迟消息：Redis ZSet（key：`ssyx.mq:delay`）
- 消费端：后台线程轮询并分发（`RedisMqConsumer`）

关键代码：

- 生产者：`common/rabbitmq-util/src/main/java/cn/itedus/ssyx/mq/service/RabbitService.java`
- 消费者：`ssyx-monolith/src/main/java/cn/itedus/ssyx/mq/RedisMqConsumer.java`

### 2.7 搜索（这版是简化实现）

- 团长搜索：MySQL 直查（`service/service-search/.../LeaderSearchController.java`）
- 商品搜索：MySQL 条件查询 + Redis 热度榜（`service/service-search/.../SkuServiceImpl.java`）

### 2.8 运行与部署（你自己能跑起来）

- 本地详细说明：`doc/本地开发环境配置指南.md`
- Docker 一键（MySQL + Redis + 应用）：`docker-compose.yml` + `Dockerfile`
- 单体配置文件：`ssyx-monolith/src/main/resources/application.yml`

---

## 3. 后端模块划分（按业务拆）

这套后端是“多模块 + 单体整合启动”的结构：按业务拆模块，最终打成一个 jar 运行。

### 3.1 你真正启动的是谁？

- 启动类：`ssyx-monolith/src/main/java/cn/itedus/ssyx/MonolithApplication.java`
- 配置文件：`ssyx-monolith/src/main/resources/application.yml`

### 3.2 模块列表（看名字就知道干什么）

- `common/`：通用能力（JWT、Redis、Swagger、拦截器、常量、工具类）
- `model/`：实体类（对应数据库表）
- `service/`：业务模块（user/product/cart/order/payment/search/home/activity...）
- `service-client/`：跨模块调用接口抽象（在单体中由 `Local*Client` 实现）
- `ssyx-monolith/`：把所有模块组合成一个可运行应用

补充说明：

- 仓库里还有 `service-geteway/`（网关 + Nacos）作为“微服务部署方案”的示例配置，但当前单体运行不依赖它。

---

## 4. 小程序前端技术栈（`youxuan_wechat/`）

针对“社区团购”场景极速加载体验要求、深度获客需要，本项目的终端业务选择不使用打包框架（如 UniApp、Taro 等），而是使用微信官方最贴近底层架构的 Native 原生范式构建。

### 4.1 核心技术选型与视图渲染

- **业务开发规范与框架层**：原生微信小程序机制（基于 `app.json` 全局配置构建视图路由底座）。
- **视图层渲染语言**：
  - **结构构建**：`WXML` (WeiXin Markup Language)，微信特有的类 HTML 标记语言。
  - **样式表现**：`WXSS` (WeiXin Style Sheets)，使用微信独家设计的 `rpx` (Responsive Pixel) 单位，实现多端等比高清自适应缩放一致性。
- **业务交互与生命周期控制**： `JavaScript (ES6+)`
- **本地存储与数据持久化**： `wx.getStorageSync` / `wx.setStorageSync`，主要保存从后端返回并验证好的业务 Token 与选定的团长信息。

### 4.2 网络请求与安全通讯层重构

- **痛点与应对**：由于原生 `wx.request` 请求庞杂不好管理，架构在 `youxuan_wechat/utils/http.js` 中对其进行了 **Promise 化自定义隔离封装**。
  - 内部集成了全局唯一的入口前置地址：`BASE_URL`。
  - 基于闭包拦截器理念实现了“发包拦截设计”，每次 HTTP 调用会在请求头全自动混入业务级的身份级别鉴权令牌 `token`。
- **接口封装分层**： `youxuan_wechat/utils/api.js` 中抽离所有外部端点映射。
- **登录状态初始化获取**：在 `youxuan_wechat/pages/login/login.js` 中实现基于 `wx.login` 获取动态凭据置换服务器端生成的长效用户状态对象。

---

## 5. 核心实现逻辑（照着讲就行）

下面是“一次完整购买”的主流程：登录 → 选提货点 → 购物车 → 下单 → 支付 → 异步处理。

### 5.1 用户登录：小程序拿到 token

**小程序侧**

1. 调 `wx.login()` 拿到临时 `code`
2. 调后端接口：`GET /api/user/weixin/wxLogin/{code}` 获取 `token`

对应代码：

- `youxuan_wechat/pages/login/login.js`
- `youxuan_wechat/utils/api.js`（`getWxLogin`）

**后端侧（核心逻辑）**

1. 用 `code` 调微信 `jscode2session` 得 `openid`
2. `openid` 查用户表：没有就创建新用户
3. 生成 JWT：`JwtHelper.createToken(userId, nickName)`
4. 把 `UserLoginVo` 放入 Redis（缓存登录态）
5. 返回：`token + user + leaderAddressVo`

对应代码：

- `service/service-user/src/main/java/cn/itedus/ssyx/user/controller/WeixinApiController.java`
- `common/common-util/src/main/java/cn/itedus/ssyx/common/utils/JwtHelper.java`
- `common/service-util/src/main/java/cn/itedus/ssyx/common/constant/RedisConst.java`

### 5.2 token 怎么在后端生效（拦截器）

每次请求 `/api/**`，后端都会：

1. 从请求头读取 `token`
2. 解析出 `userId`
3. 写入 `AuthContextHolder`（线程变量 ThreadLocal）

这样业务代码里就能直接拿当前用户：

- `AuthContextHolder.getUserId()`

对应代码：

- `common/service-util/src/main/java/cn/itedus/ssyx/common/auth/UserLoginInterceptor.java`
- `common/service-util/src/main/java/cn/itedus/ssyx/common/auth/LoginMvcConfigurerAdapter.java`

### 5.3 选择提货点（团长）

小程序要能下单，必须有提货点信息（团长/自提点）。

- 搜索提货点列表：`GET /api/search/leader/{page}/{limit}`
  - 本版本用 MySQL 直接查（不走 ES）
- 选择提货点：`GET /api/user/leader/auth/selectLeader/{leaderId}`
  - 后端把该提货点绑定到用户（写 `user_delivery` 等关系表）

对应代码：

- 提货点搜索：`service/service-search/.../LeaderSearchController.java`
- 选择提货点：`service/service-user/.../api/LeaderApiController.java`
- 绑定/兜底逻辑：`service/service-user/.../service/impl/UserServiceImpl.java`

> 小提示（毕设友好）：`UserServiceImpl` 里做了“兜底”，如果用户没有默认提货点，会自动绑定一个可用提货点，保证流程能跑通。

### 5.4 购物车：为什么用 Redis

购物车是典型“读写非常频繁”的功能，适合放缓存。

实现方式：每个用户一个 Redis Hash：

- key：`user:{userId}:cart`
- field：`skuId`
- value：`CartInfo`（商品名、数量、是否勾选等）
- 过期时间：7 天（`RedisConst.USER_CART_EXPIRE`）

对应代码：

- `service/service-cart/.../CartInfoServiceImpl.java`
- Redis key 常量：`common/service-util/.../constant/RedisConst.java`

### 5.5 下单（最核心）：防重 + 锁库存 + 落库

#### A) 确认订单（生成防重订单号）

接口：`GET /api/order/auth/confirmOrder`

做了三件事：

1. 读当前用户的提货点信息（团长地址）
2. 读已勾选的购物车商品
3. 生成 `orderNo`，写入 Redis（防重 key）

对应代码：

- `service/service-order/.../OrderInfoServiceImpl.java` → `confirmOrder()`

#### B) 提交订单（真正创建订单）

接口：`POST /api/order/auth/submitOrder`

关键步骤：

1. **校验防重**：Redis + Lua（只能提交一次）
2. **锁库存**：调用 `productFeignClient.checkAndLock(...)`
3. **写订单**：事务写入 `order_info` + `order_item`
4. **发异步消息**：清除购物车里已下单项（走“Redis MQ”）

对应代码：

- `service/service-order/.../OrderInfoServiceImpl.java` → `submitOrder()`、`saveOrder(...)`
- 锁库存实现：`service/service-product/.../SkuInfoServiceImpl.java` → `checkAndLock(...)`
- 发消息：`common/rabbitmq-util/.../RabbitService.java`

**为什么要“防重”**

小程序可能会因为网络卡顿/用户连点“提交”，导致重复请求；  
防重保证：同一个 `orderNo` 只能成功一次。

**为什么要“锁库存”**

多人同时买同一个商品时，如果不锁库存，就会发生“超卖”。  
锁库存保证：库存扣减是安全的（并发下仍正确）。

### 5.6 支付：微信统一下单 → 查状态 → 支付成功处理

小程序支付相关主要是两步：

1. 生成支付参数：`GET /api/payment/weixin/createJsapi/{orderNo}`
2. 轮询查支付结果：`GET /api/payment/weixin/queryPayStatus/{orderNo}`

后端核心：

- `createJsapi`：调用微信支付统一下单接口，返回小程序调起支付需要的参数
- `queryPayStatus`：查到 `SUCCESS` 后，调用 `paySuccess(...)` 处理支付成功逻辑

对应代码：

- `service/service-payment/.../WeixinController.java`
- `service/service-payment/.../WeixinServiceImpl.java`
- `service/service-payment/.../PaymentInfoServiceImpl.java`

### 5.7 支付成功后发生了什么（异步串起来）

支付成功后，系统会发一条“支付成功”的消息，消费端收到后会：

1. 更新订单状态（未支付 → 待发货/待配送）
2. 发“扣库存”消息（最终扣减 MySQL 库存）
3. 下单后还会发“清购物车”消息（把购物车里已勾选项删掉）

对应代码：

- 发消息：`common/rabbitmq-util/.../RabbitService.java`
- 消费分发：`ssyx-monolith/.../mq/RedisMqConsumer.java`
- 更新订单状态：`service/service-order/.../OrderInfoServiceImpl.java` → `orderPay(...)`
- 扣库存：`service/service-product/.../SkuInfoServiceImpl.java` → `minusStock(...)`
- 清购物车：`service/service-cart/.../CartInfoServiceImpl.java` → `deleteCartChecked(...)`

---

## 6. 小程序调用接口速查（对照表）

> 你可以在汇报时说：前端 API 都集中封装在 `youxuan_wechat/utils/api.js`。

- 登录：`GET /api/user/weixin/wxLogin/{code}`
- 首页：`GET /api/home/index`
- 商品搜索：`GET /api/search/sku/{page}/{limit}`
- 团长/提货点搜索：`GET /api/search/leader/{page}/{limit}`
- 选择提货点：`GET /api/user/leader/auth/selectLeader/{leaderId}`
- 购物车：
  - 加入：`GET /api/cart/addToCart/{skuId}/{skuNum}`
  - 列表：`GET /api/cart/cartList`
  - 勾选：`GET /api/cart/checkCart/{skuId}/{isChecked}`
  - 删除：`DELETE /api/cart/deleteCart/{skuId}`
- 下单：
  - 确认：`GET /api/order/auth/confirmOrder`
  - 提交：`POST /api/order/auth/submitOrder`
- 订单列表：`GET /api/order/auth/findUserOrderPage/{page}/{limit}`
- 支付：
  - 统一下单：`GET /api/payment/weixin/createJsapi/{orderNo}`
  - 查支付：`GET /api/payment/weixin/queryPayStatus/{orderNo}`

---

## 7. 数据库脚本与配置位置（老师问“数据从哪来”时用）

- 初始化 SQL：`doc/sql/*.sql`
  - `shequ-user.sql`、`shequ-product.sql`、`shequ-activity.sql`、`shequ-order.sql` 等
- 后端配置：`ssyx-monolith/src/main/resources/application.yml`
- Docker 一键启动 MySQL+Redis：`docker-compose.yml`
- 打包与运行镜像：`Dockerfile`
- 更详细的本地运行说明：`doc/本地开发环境配置指南.md`

---

## 8. 汇报时高频问题（背 6 句就够）

1. **为什么用 Redis？**  
   购物车、登录态、热度榜都是高频读写，放 Redis 性能更好，数据库压力更小。
2. **为什么要 JWT？**  
   小程序每次请求带 token，后端就能识别用户身份，接口更安全。
3. **为什么下单要防重？**  
   防止用户连点/网络重试造成重复订单。
4. **为什么库存要加锁？**  
   防止并发超卖，保证库存扣减的正确性。
5. **为什么要异步消息？**  
   “下单后清购物车”“支付后扣库存”这些不是必须同步完成的，异步能让接口更快、体验更好。
6. **为什么搜索没用 ES？**  
   毕设版本优先跑通与易部署：用 MySQL + Redis 热度实现搜索能力，并保留未来升级 ES 的空间。

---

## 9. 你讲的时候推荐顺序（照读版）

1) 先用“0.一句话介绍”开场  
2) 展示“1.结构图”  
3) 用“2.后端技术栈”快速过一遍关键词  
4) 重点讲“5.核心实现逻辑”（登录→购物车→下单→支付→异步）  
5) 老师追问就翻“6/7/8”对应回答
